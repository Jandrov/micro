Turbo Assembler	 Version 2.0	    04/13/18 18:56:18	    Page 1
pract3b.ASM



      1				     ;**************************************************************************
      2				     ; MICROPROCESSOR-BASED SYSTEMS
      3				     ; LAB SESSION 2
      4				     ; FILE: pract3b.asm
      5				     ; AUTHORS:	Emilio Cuesta Fernandez	- Alejandro Sanchez Sanz
      6				     ; COUPLE NUMBER: 8
      7				     ; GROUP: 2351
      8				     ;**************************************************************************
      9
     10				     ; CODE SEGMENT DEFINITION
     11	0000			     _TEXT SEGMENT BYTE	PUBLIC 'CODE'
     12				     ASSUME CS:	_TEXT
     13
     14				     PUBLIC _computeMatches
     15	0000			     _computeMatches PROC FAR
     16
     17
     18	0000  55			 PUSH BP	 ; We push BP because we want the main program stack to	be accesed correctly+
     19				     after these function.
     20							 ; Without that	value, the main	program	would lose the reference.
     21	0001  8B EC			 MOV BP, SP	 ; Now,	we initialice BP as SP (which points to	the last pushed	element	in  +
     22				     the stack)
     23							 ; We do that to access	the arguments of the function in an easier way:
     24							 ;   * All the passed arguments	can be accesed like this: [BP +	X],  being X+
     25				     an	integer	which
     26							 ;     correct values depends on the number and	the size of the	arguments.
     27							 ; These also allows us	to have	some local variables under BP (BP - X),	but +
     28				     they aren't needed	in this	function
     29
     30					 ; IMPORTANT: It is necessary to save the register values that the calling program had and  +
     31				     restore them at the end of	the procedure.
     32					 ; If we dont do that, we might	modifiy	something the program doesnt expect to be modified.
     33
     34	0003  53 51 52 57 06 1E		 PUSH BX CX DX DI ES DS	; It is	necessary to push de ES/DS register because of the LES/LEA  +
     35				     instruction, that modifies	it.
     36							     ; We dont store Ax	because	we are supposed	to write the return value on+
     37				     it.
     38
     39
     40					 ; The arguments of this function are:
     41					 ;		    * unsigned char* secretNum
     42					 ;		    * unsigned char* attemptDigits
     43					 ;
     44					 ; The return direction	gaps takes 4 bytes (2 bytes from segment and another 2 from offset).
     45					 ; The BP gap takes another 2 bytes
     46
     47					 ; The current stack state is similar to this:	 SEG attemptDigits	BP+12
     48					 ;						 OFFSET	attemptDigits	BP+10
     49					 ;						 SEG secretNum		BP+8
     50					 ;						 OFFSET	secretNum	BP+6
     51					 ;						 SEG return@		BP+4
     52					 ;						 OFFSET	return@		BP+2
     53					 ;						 BP			BP
     54					 ;						 ...
     55
     56
     57					 ; Loading arguments
Turbo Assembler	 Version 2.0	    04/13/18 18:56:18	    Page 2
pract3b.ASM



     58
     59	0009  C4 5E 06			 LES BX, [BP + 6]	     ; We store	secretNum direction in ES/BX
     60	000C  C5 4E 0A			 LDS CX, [BP + 10]	     ; We store	attemptDigits direction	in DS/CX
     61
     62
     63	000F  B8 0000			 MOV AX, 0		     ; We initialice the number	of coincidences	to 0
     64	0012  BF 0000			 MOV DI, 0		     ; We will iterate using DI
     65
     66	0015			     LOOPING:
     67
     68	0015  8B 5E 06			 MOV BX, [BP+6]
     69	0018  26: 8A 31			 MOV DH, ES:[BX][DI]	     ; Loading in DH the secretNum digit indicated by DI
     70	001B  8B D9			 MOV BX, CX
     71	001D  8A 11			 MOV DL, DS:[BX][DI]	     ; Loading in DL the attempDigits digit indicated by DI
     72	001F  3A F2			 CMP DH, DL		     ; We compare their	ASCII codes
     73	0021  74 09			 JE COINCIDENCE		     ; If they are equal, we jump
     74
     75	0023			     BACKSTEP:
     76
     77	0023  47			 INC DI			     ; We increment DI
     78	0024  83 FF 04			 CMP DI, 4		     ; Stop condition: The 4 digits have already been compared.
     79	0027  75 EC			 JNE LOOPING		     ; Restart the loop
     80
     81	0029  EB 06 90			 JMP ENDING		     ; End of loop
     82
     83	002C			     COINCIDENCE:
     84
     85	002C  05 0001			 ADD AX, 1		     ; If a coincidence	has happened, we increment the value of	AX  +
     86				     (which is also where the return value must	be stored)
     87	002F  EB F2			 JMP BACKSTEP		     ; The loop	must go	on until the Stop Condition is True
     88
     89
     90	0031			     ENDING:
     91
     92					 ; Restoring
     93	0031  1F 07 5F 5A 59 5B		 POP DS	ES DI DX CX BX
     94	0037  5D			 POP BP
     95
     96	0038  CB			 ret
     97	0039			     _computeMatches ENDP
     98
     99
    100				     PUBLIC _computeSemiMatches
    101	0039			     _computeSemiMatches PROC FAR
    102
    103	0039  55			 PUSH BP	 ; We push BP because we want the main program stack to	be accesed correctly+
    104				     after these function.
    105							 ; Without that	value, the main	program	would lose the reference.
    106	003A  8B EC			 MOV BP, SP	 ; Now,	we initialice BP as SP (which points to	the last pushed	element	in  +
    107				     the stack)
    108							 ; We do that to access	the arguments of the function in an easier way:
    109							 ;   * All the passed arguments	can be accesed like this: [BP +	X],  being X+
    110				     an	integer	which
    111							 ;     correct values depends on the number and	the size of the	arguments.
    112							 ; These also allows us	to have	some local variables under BP (BP - X),	but +
    113				     they aren't needed	in this	function
    114
Turbo Assembler	 Version 2.0	    04/13/18 18:56:18	    Page 3
pract3b.ASM



    115					 ; IMPORTANT: It is necessary to save the register values that the calling program had and  +
    116				     restore them at the end of	the procedure.
    117					 ; If we dont do that, we might	modifiy	something the program doesnt expect to be modified.
    118
    119	003C  53 51 52 57 56 06	1E	 PUSH BX CX DX DI SI ES	DS ; It	is necessary to	push de	ES/DS register because of the	    +
    120				     LES/LDS instruction, that modifies	it.
    121								   ; We	dont store AX because we are supposed to write the return   +
    122				     value on it.
    123
    124
    125					 ; The arguments of this function are:
    126					 ;		    * unsigned char* secretNum
    127					 ;		    * unsigned char* attemptDigits
    128					 ;
    129					 ; The return direction	gaps takes 4 bytes (2 bytes from segment and another 2 from offset).
    130					 ; The BP gap takes another 2 bytes
    131
    132					 ; The current stack state is similar to this:	 SEG attemptDigits	BP+12
    133					 ;						 OFFSET	attemptDigits	BP+10
    134					 ;						 SEG secretNum		BP+8
    135					 ;						 OFFSET	secretNum	BP+6
    136					 ;						 SEG return@		BP+4
    137					 ;						 OFFSET	return@		BP+2
    138					 ;						 BP			BP
    139					 ;						 ...
    140
    141
    142					 ; Loading arguments
    143
    144	0043  C4 4E 06			 LES CX, [BP + 6]	     ; We store	secretNum direction in ES/CX
    145	0046  C5 5E 0A			 LDS BX, [BP + 10]	     ; We store	attemptDigits direction	in DS/BX
    146
    147
    148	0049  B8 0000			 MOV AX, 0		     ; We initialice the number	of semimatches to 0
    149	004C  BF 0000			 MOV DI, 0		     ; We will iterate in secretNum using DI
    150	004F  BE 0000			 MOV SI, 0		     ; We will iterate in atemptDigits using SI
    151
    152	0052			     EXTERNAL:
    153	0052  8B 5E 0A			 MOV BX, [BP + 10]
    154	0055  8A 10			 MOV DL, DS:[BX][SI]	     ; Loading in DL the attempDigits digit indicated by SI
    155
    156	0057			     INCREMENT:
    157	0057  3B F7			 CMP SI, DI		     ; Comparing both indexes because matches are not considered as +
    158				     semimatches
    159	0059  75 06			 JNE INTERNAL
    160	005B  47			 INC DI			     ; If they are equal, we increment attemptDigits' index
    161	005C  83 FF 04			 CMP DI, 4		     ; This would be true after	comparing last digit of	secretNum   +
    162				     with third	digit of attemptDigits
    163	005F  74 20			 JE FINISH		     ; In this case, the iteration has finished
    164
    165	0061			     INTERNAL:
    166	0061  8B D9			 MOV BX, CX
    167	0063  26: 8A 31			 MOV DH, ES:[BX][DI]	     ; Loading in DH the secretNum digit indicated by DI
    168
    169	0066  3A F2			 CMP DH, DL		     ; We compare their	ASCII codes
    170	0068  74 12			 JE SEMIMATCH		     ; If they are equal, we jump
    171
Turbo Assembler	 Version 2.0	    04/13/18 18:56:18	    Page 4
pract3b.ASM



    172	006A			     CHECKS:
    173
    174	006A  47			 INC DI			     ; We increment DI (internal loop index)
    175	006B  83 FF 04			 CMP DI, 4		     ; Stop condition: The 4 digits have already been compared.
    176	006E  75 E7			 JNE INCREMENT		     ; Restart the internal loop
    177	0070  BF 0000			 MOV DI, 0		     ; We reset	attemptDigits' index to	restart	the external loop
    178	0073  46			 INC SI			     ; We increment SI (external loop index)
    179	0074  83 FE 04			 CMP SI, 4		     ; Stop condition
    180	0077  75 D9			 JNE EXTERNAL		     ; Restart the external loop
    181
    182	0079  EB 06 90			 JMP FINISH		     ; End of loop
    183
    184	007C			     SEMIMATCH:
    185
    186	007C  05 0001			 ADD AX, 1		     ; If a coincidence	has happened, we increment the value of	AX  +
    187				     (which is also where the return value must	be stored)
    188	007F  EB E9			 JMP CHECKS		     ; The loop	must go	on until the Stop Condition is True
    189
    190
    191	0081			     FINISH:
    192
    193					 ; Restoring
    194	0081  1F 07 5E 5F 5A 59	5B	 POP DS	ES SI DI DX CX BX
    195	0088  5D			 POP BP
    196
    197	0089  CB			 ret
    198	008A			     _computeSemiMatches ENDP
    199
    200
    201				     ; END OF CODE SEGMENT
    202	008A			     _TEXT ENDS
    203				     END
Turbo Assembler	 Version 2.0	    04/13/18 18:56:18	    Page 5
Symbol Table




Symbol Name			  Type	 Value

??date				  Text	 "04/13/18"
??filename			  Text	 "pract3b "
??time				  Text	 "18:56:17"
??version			  Number 0200
@Cpu				  Text	 0101H
@FileName			  Text	 pract3b
@WordSize			  Text	 2
@curseg				  Text	 _TEXT
BACKSTEP			  Near	 _TEXT:0023
CHECKS				  Near	 _TEXT:006A
COINCIDENCE			  Near	 _TEXT:002C
ENDING				  Near	 _TEXT:0031
EXTERNAL			  Near	 _TEXT:0052
FINISH				  Near	 _TEXT:0081
INCREMENT			  Near	 _TEXT:0057
INTERNAL			  Near	 _TEXT:0061
LOOPING				  Near	 _TEXT:0015
SEMIMATCH			  Near	 _TEXT:007C
_computeMatches			  Far	 _TEXT:0000
_computeSemiMatches		  Far	 _TEXT:0039

Groups & Segments		  Bit Size Align  Combine Class

_TEXT				  16  008A Byte	  Public  CODE
