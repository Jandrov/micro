Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 1
p4c.asm



      1				     ;**************************************************************************
      2				     ; MICROPROCESSOR-BASED SYSTEMS
      3				     ; LAB SESSION 4
      4				     ; FILE: p4c.asm
      5				     ; AUTHORS:	Emilio Cuesta Fernandez	- Alejandro Sanchez Sanz
      6				     ; COUPLE NUMBER: 8
      7				     ; GROUP: 2351
      8				     ;**************************************************************************
      9
     10
     11				     ; DATA SEGMENT DEFINITION
     12	0000			     DATOS SEGMENT
     13					     ; Functionality variables
     14	0000  00			     COD_DEC DB	0  ; It	is 0 if	we want	to ENCODE.
     15								; Its value is 1 if we wanto to	DECRYPT
     16	0001  64*(??)			 MESSAGE DB 100	dup (?)
     17
     18					     ; Variables to print
     19	0065  1B 5B 32 4A 24		     CLEAR_SCREEN    DB	     1BH,"[2","J$"
     20	006A  54 68 65 20 64 72	69+	     ERRORCODE DB  "The	driver you are trying to use is	not correctly installed.", 13, 10,  +
     21	      76 65 72 20 79 6F	75+  "Please, try running P4C.COM /I before", 13, 10, '$'
     22	      20 61 72 65 20 74	72+
     23	      79 69 6E 67 20 74	6F+
     24	      20 75 73 65 20 69	73+
     25	      20 6E 6F 74 20 63	6F+
     26	      72 72 65 63 74 6C	79+
     27	      20 69 6E 73 74 61	6C+
     28	      6C 65 64 2E 0D 0A	50+
     29	      6C 65 61 73 65 2C	20+
     30	      74 72 79 20 72 75	6E+
     31	      6E 69 6E 67 20 50	34+
     32	      43 2E 43 4F 4D 20	2F+
     33	      49 20 62 65 66 6F	72+
     34	      65 0D 0A 24
     35	00D0  54 68 65 20 63 75	72+	     MODESTRING	DB "The	current	mode is: " , '$'
     36	      72 65 6E 74 20 6D	6F+
     37	      64 65 20 69 73 3A	20+
     38	      24
     39	00E6  43 4F 44 0D 0A 24		     CODSTRING DB "COD", 13, 10	, '$'
     40	00EC  44 45 43 0D 0A 24		     DECSTRING DB "DEC", 13, 10	, '$'
     41	00F2  50 6C 65 61 73 65	2C+	     STATEMENT DB  "Please, write a message or a command: ", 13, 10, '$'
     42	      20 77 72 69 74 65	20+
     43	      61 20 6D 65 73 73	61+
     44	      67 65 20 6F 72 20	61+
     45	      20 63 6F 6D 6D 61	6E+
     46	      64 3A 20 0D 0A 24
     47	011B  54 68 65 20 6D 65	73+	     PRINTMESSAGE DB "The message you introduced is: ",	'$'
     48	      73 61 67 65 20 79	6F+
     49	      75 20 69 6E 74 72	6F+
     50	      64 75 63 65 64 20	69+
     51	      73 3A 20 24
     52	013B  54 68 65 20 65 6E	63+	     CODMESSAGE	DB "The	encoded	message	is:", 13, 10, '$'
     53	      6F 64 65 64 20 6D	65+
     54	      73 73 61 67 65 20	69+
     55	      73 3A 0D 0A 24
     56	0155  54 68 65 20 64 65	63+	     DECMESSAGE	DB "The	decoded	message	is:", 13, 10, '$'
     57	      6F 64 65 64 20 6D	65+
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 2
p4c.asm



     58	      73 73 61 67 65 20	69+
     59	      73 3A 0D 0A 24
     60
     61	016F  0D 0A 24			 LINEJUMP DB 13,10, '$'
     62
     63	0172			     DATOS ENDS
     64				     ;**************************************************************************
     65				     ; STACK SEGMENT DEFINITION
     66	0000			     PILA SEGMENT STACK	"STACK"
     67	0000  40*(00)			     DB	40h DUP	(0) ; initialization example, 64 bytes set to 0
     68	0040			     PILA ENDS
     69
     70
     71				     ;**************************************************************************
     72				     ; CODE SEGMENT DEFINITION
     73	0000			     CODE SEGMENT
     74				     ASSUME CS:	CODE, DS: DATOS, SS: PILA
     75					     ; First assembly instruction must be after	the 256	bytes of PSP, so this is
     76					     ; necessary to generate a .COM file
     77					     ORG 256
     78
     79
     80				     ; BEGINNING OF THE	MAIN PROCEDURE
     81
     82
     83
     84	0100			     INICIO PROC
     85					     ; INITIALIZE THE SEGMENT REGISTERS
     86	0100  B8 0000s			     MOV AX, DATOS
     87	0103  8E D8			     MOV DS, AX
     88	0105  B8 0000			     MOV AX, 0
     89	0108  8E C0			     MOV ES, AX
     90
     91
     92					     ; We have to check	if our driver is correcly installed
     93					     ;MOV AH, 0
     94					     ;CALL CHECK_DRIVER
     95					     ;CMP AH, 1
     96					     ;JE DRIVER_OK
     97	010A  EB 0B 90			     JMP DRIVER_OK
     98
     99	010D			     ERROR:
    100
    101					     ; If the driver isnt well installed, we print an advise and the program finishes
    102					     ; Printing	an ERRORCODE
    103	010D  BA 006Ar			     MOV DX, OFFSET ERRORCODE
    104	0110  B4 09			     MOV AH, 9
    105	0112  CD 21			     INT 21H
    106
    107	0114  E9 00E7			     JMP JEND
    108
    109	0117			     DRIVER_OK:
    110
    111					     ; We set up all the RTC configuration in this function
    112	0117  E8 0114			     CALL RTC_CONFIG
    113
    114					     ; CLEARS THE SCREEN
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 3
p4c.asm



    115	011A  B4 09			     MOV AH,9
    116	011C  BA 0065r			     MOV DX, OFFSET CLEAR_SCREEN
    117	011F  CD 21			     INT 21H
    118
    119
    120	0121			     KEYBOARD_LOOP:
    121
    122					     ; Printing	the current mode
    123	0121  BA 00D0r			     MOV DX, OFFSET MODESTRING
    124	0124  CD 21			     INT 21H
    125
    126	0126  80 3E 0000r 00		     CMP COD_DEC, 0
    127	012B  75 08			     JNE DEC_PRINT
    128
    129	012D  BA 00E6r			     MOV DX, OFFSET CODSTRING
    130	0130  CD 21			     INT 21H
    131
    132	0132  EB 06 90			     JMP SCANF
    133
    134	0135			     DEC_PRINT:
    135
    136	0135  BA 00ECr			     MOV DX, OFFSET DECSTRING
    137	0138  CD 21			     INT 21H
    138
    139	013A			     SCANF:
    140
    141					     ; PRINTS THE MESSAGE REQUEST
    142	013A  BA 00F2r			     MOV DX, OFFSET STATEMENT
    143	013D  CD 21			     INT 21H
    144
    145					     ; STORES THE MESSAGE IN MEMORY
    146	013F  B4 0A			     MOV AH,0AH
    147	0141  BA 0001r			     MOV DX, OFFSET MESSAGE
    148	0144  C6 06 0001r 5A		     MOV MESSAGE[0], 90
    149	0149  CD 21			     INT 21H
    150
    151					     ; Check out if the	MESSAGE'S lenght is not	null
    152	014B  B7 00			     MOV BH, 0
    153	014D  8A 1E 0002r		     MOV BL, MESSAGE[1]
    154	0151  80 FB 00			     CMP BL, 0
    155	0154  74 CB			     JE	KEYBOARD_LOOP
    156
    157
    158					     ; In order	to print the message correctly,	we have	to write the $ right after the last +
    159				     character
    160	0156  C6 87 0003r 24		     MOV MESSAGE[BX+2],	'$'
    161
    162					     ; First of	all, we	check out if the given string is one of	our commands.s
    163
    164					     ; Quit comparison
    165	015B  80 3E 0003r 51		     CMP MESSAGE[2], 'Q'
    166	0160  75 18			     JNE COD_CMP
    167	0162  80 3E 0004r 55		     CMP MESSAGE[3], 'U'
    168	0167  75 11			     JNE COD_CMP
    169	0169  80 3E 0005r 49		     CMP MESSAGE[4], 'I'
    170	016E  75 0A			     JNE COD_CMP
    171	0170  80 3E 0006r 54		     CMP MESSAGE[5], 'T'
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 4
p4c.asm



    172	0175  75 03			     JNE COD_CMP
    173
    174					     ; In this case the	QUIT command has been written. The program ends
    175
    176	0177  E9 0084			     JMP JEND
    177
    178	017A			     COD_CMP:
    179
    180	017A  80 3E 0003r 43		     CMP MESSAGE[2], 'C'
    181	017F  75 1C			     JNE DEC_CMP
    182	0181  80 3E 0004r 4F		     CMP MESSAGE[3], 'O'
    183	0186  75 15			     JNE DEC_CMP
    184	0188  80 3E 0005r 44		     CMP MESSAGE[4], 'D'
    185	018D  75 0E			     JNE DEC_CMP
    186
    187
    188					     ; In this case the	COD command has	been written. We change	the mode-flag
    189
    190	018F  C6 06 0000r 00		     MOV COD_DEC, 0
    191
    192					     ; Printing	a line jump
    193	0194  B4 09			     MOV AH,9
    194	0196  BA 016Fr			     MOV DX, OFFSET LINEJUMP
    195	0199  CD 21			     INT 21H
    196
    197	019B  EB 84			     JMP KEYBOARD_LOOP
    198
    199	019D			     DEC_CMP:
    200
    201	019D  80 3E 0003r 44		     CMP MESSAGE[2], 'D'
    202	01A2  75 1D			     JNE STRING_MODE
    203	01A4  80 3E 0004r 45		     CMP MESSAGE[3], 'E'
    204	01A9  75 16			     JNE STRING_MODE
    205	01AB  80 3E 0005r 43		     CMP MESSAGE[4], 'C'
    206	01B0  75 0F			     JNE STRING_MODE
    207
    208					     ; In this case the	DEC command has	been written. We change	the mode-flag
    209
    210	01B2  C6 06 0000r 01		     MOV COD_DEC, 1
    211
    212					     ; Printing	a line jump
    213	01B7  B4 09				     MOV AH,9
    214
    215	01B9  BA 016Fr			     MOV DX, OFFSET LINEJUMP
    216	01BC  CD 21			     INT 21H
    217
    218	01BE  E9 FF60			     JMP KEYBOARD_LOOP
    219
    220	01C1			     STRING_MODE:
    221
    222					     ; PRINTS THE MESSAGE WRITTEN BY THE USER
    223	01C1  B4 09			     MOV AH,9
    224	01C3  BA 011Br			     MOV DX, OFFSET PRINTMESSAGE
    225	01C6  CD 21			     INT 21H
    226
    227	01C8  BA 0003r			     MOV DX, OFFSET MESSAGE[2]
    228	01CB  CD 21			     INT 21H
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 5
p4c.asm



    229
    230					     ; Printing	a line jump
    231	01CD  BA 016Fr			     MOV DX, OFFSET LINEJUMP
    232	01D0  CD 21			     INT 21H
    233
    234
    235	01D2  80 3E 0000r 00		     CMP COD_DEC, 0
    236	01D7  75 0A			     JNE DEC_MODE
    237
    238					     ; CASE 1: ENCRYPTION
    239
    240	01D9  BA 013Br			     MOV DX, OFFSET CODMESSAGE
    241	01DC  CD 21			     INT 21H
    242
    243					     ; 12h => ENCRYPTION
    244	01DE  B4 12			     MOV AH, 12h
    245	01E0  EB 08 90			     JMP INT_CALL
    246
    247
    248					     ; CASE 2: DECRYPTION
    249
    250	01E3			     DEC_MODE:
    251
    252	01E3  BA 0155r			     MOV DX, OFFSET DECMESSAGE
    253	01E6  CD 21			     INT 21H
    254
    255					     ; 13h => DECRYPTION
    256	01E8  B4 13			     MOV AH, 13h
    257
    258	01EA			     INT_CALL:
    259
    260					     ; We push DS in order to keep it: We might	need it	later
    261	01EA  1E			     PUSH DS
    262
    263					     ; We use message[2] because the first two bytes of	the read message are the maximum    +
    264				     size and the real size.
    265					     ; We dont want to codify them
    266	01EB  BA 0003r			     MOV DX, OFFSET MESSAGE[2]
    267	01EE  BB 0000s			     MOV BX, SEG MESSAGE
    268	01F1  8E DB			     MOV DS, BX
    269
    270					     ; Calling of the interruption
    271					     ;INT 55h
    272
    273					     ; Restoring DS
    274	01F3  1F			     POP DS
    275
    276					     ; Printing	a line jump
    277	01F4  B4 09			     MOV AH, 9h
    278	01F6  BA 016Fr			     MOV DX, OFFSET LINEJUMP
    279	01F9  CD 21			     INT 21H
    280
    281
    282					     ; Active wait. We wait till the RTC interruption ends up printing the encoded/decoded  +
    283				     string
    284
    285					     ; TODO
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 6
p4c.asm



    286
    287					     ; After the interruption, the user	will be	asked for another string once and again	till+
    288				     it	writes the QUIT	command
    289	01FB  E9 FF23			     JMP KEYBOARD_LOOP
    290
    291					     ; PROGRAM END
    292	01FE			     JEND:
    293	01FE  B8 4C00			 MOV AX, 4C00h
    294	0201  CD 21			     INT 21h
    295	0203			     INICIO ENDP
    296
    297
    298				     ; This function writes on CL
    299				     ; After the execution:
    300				     ; CL = 0 if there isnt any	driver at 55h
    301				     ; CL = 1 if the installed driver is ours.
    302				     ; CL = 2 if there is a driver, but	it is not ours.
    303	0203			     CHECK_DRIVER PROC NEAR
    304
    305	0203  57 56 50			     PUSH DI SI	AX
    306
    307					     ; We have to check	if there is a driver in	55h
    308					     ; If so, we would like to know if it is our driver
    309	0206  26: 8B 3E	0154		     MOV DI, ES:[ 55h*4	]
    310	020B  26: 8B 36	0156		     MOV SI, ES:[ 55h*4	+2 ]
    311					     ; We check	if there are 0s	in the interruption vector
    312	0210  83 FF 00			     CMP DI, 0
    313	0213  75 0A			     JNE DRIVER_EXISTS
    314	0215  83 FE 00			     CMP SI, 0
    315	0218  75 05			     JNE DRIVER_EXISTS
    316
    317					     ; If we have reached this point it	means there is no driver installed at all.
    318	021A  B4 00			     MOV AH, 0
    319	021C  EB 0C 90			     JMP END_CHECK
    320
    321	021F			     DRIVER_EXISTS:
    322
    323	021F  B4 08			     MOV AH, 08h
    324	0221  CD 55			     INT 55h
    325					     ; If the interruption with	AH = 08h changes CL from 0 to 1, then it should	be our	    +
    326				     interruption.
    327	0223  80 FC 01			     CMP AH, 1
    328	0226  74 02			     JE	END_CHECK
    329
    330					     ; The other possible case is: there is a driver, but it isnt the one we want.
    331	0228  B4 02			     MOV AH, 2
    332
    333	022A			     END_CHECK:
    334	022A  58 5E 5F			     POP AX SI DI
    335	022D  C3			     RET
    336
    337	022E			     CHECK_DRIVER ENDP
    338
    339	022E			     RTC_CONFIG	PROC NEAR
    340	022E  50			     PUSH AX
    341
    342					     ; Enable RTC on slave PIC
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 7
p4c.asm



    343	022F  E4 A1			     IN	AL, 0A1h	     ; Read IMR	of PIC-1 (Slave)
    344	0231  24 FE			     AND AL, 11111110b
    345	0233  E6 A1			     OUT 0A1h, AL	     ; Write IMR of PIC-1 (Slave)
    346
    347	0235  B0 0A			     MOV AL, 0Ah
    348					     ; Set the frequency
    349	0237  E6 70			     OUT 70h, AL	     ; Enable 0Ah register
    350	0239  B0 2F			     MOV AL, 00101111b	     ; DV=010b,	RS=1110b (14 ==	4 Hz)
    351	023B  E6 71			     OUT 71h, AL	     ; Write 0Ah register
    352					     ; Active interrupt
    353	023D  B0 0B			     MOV AL, 0Bh
    354	023F  E6 70			     OUT 70h, AL	     ; Enable 0Bh register
    355	0241  E4 71			     IN	AL, 71h			     ; Read the	0Bh register
    356	0243  8A E0			     MOV AH, AL
    357	0245  80 CC 40			     OR	AH, 01000000b	     ; Set the PIE bit
    358	0248  B0 0B			     MOV AL, 0Bh
    359	024A  E6 70			     OUT 70h, AL	     ; Enable the 0Bh register
    360	024C  8A C4			     MOV AL, AH
    361	024E  E6 71			     OUT 71h, AL	     ; Write the 0Bh register
    362	0250  58			     POP AX
    363	0251  C3			     RET
    364	0252			     RTC_CONFIG	ENDP
    365
    366
    367				     ; END OF CODE SEGMENT
    368	0252			     CODE ENDS
    369				     ; END OF PROGRAM.
    370				     END INICIO
Turbo Assembler	 Version 2.0	    05/03/18 02:29:33	    Page 8
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "05/03/18"
??FILENAME			  Text	 "p4c	  "
??TIME				  Text	 "02:29:32"
??VERSION			  Number 0200
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 P4C
@WORDSIZE			  Text	 2
CHECK_DRIVER			  Near	 CODE:0203
CLEAR_SCREEN			  Byte	 DATOS:0065
CODMESSAGE			  Byte	 DATOS:013B
CODSTRING			  Byte	 DATOS:00E6
COD_CMP				  Near	 CODE:017A
COD_DEC				  Byte	 DATOS:0000
DECMESSAGE			  Byte	 DATOS:0155
DECSTRING			  Byte	 DATOS:00EC
DEC_CMP				  Near	 CODE:019D
DEC_MODE			  Near	 CODE:01E3
DEC_PRINT			  Near	 CODE:0135
DRIVER_EXISTS			  Near	 CODE:021F
DRIVER_OK			  Near	 CODE:0117
END_CHECK			  Near	 CODE:022A
ERROR				  Near	 CODE:010D
ERRORCODE			  Byte	 DATOS:006A
INICIO				  Near	 CODE:0100
INT_CALL			  Near	 CODE:01EA
JEND				  Near	 CODE:01FE
KEYBOARD_LOOP			  Near	 CODE:0121
LINEJUMP			  Byte	 DATOS:016F
MESSAGE				  Byte	 DATOS:0001
MODESTRING			  Byte	 DATOS:00D0
PRINTMESSAGE			  Byte	 DATOS:011B
RTC_CONFIG			  Near	 CODE:022E
SCANF				  Near	 CODE:013A
STATEMENT			  Byte	 DATOS:00F2
STRING_MODE			  Near	 CODE:01C1

Groups & Segments		  Bit Size Align  Combine Class

CODE				  16  0252 Para	  none
DATOS				  16  0172 Para	  none
PILA				  16  0040 Para	  Stack	  STACK
