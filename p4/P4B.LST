Turbo Assembler	 Version 2.0	    05/03/18 02:29:32	    Page 1
p4b.asm



      1				     ;**************************************************************************
      2				     ; MICROPROCESSOR-BASED SYSTEMS
      3				     ; LAB SESSION 4
      4				     ; FILE: p4b.asm
      5				     ; AUTHORS:	Emilio Cuesta Fernandez	- Alejandro Sanchez Sanz
      6				     ; COUPLE NUMBER: 8
      7				     ; GROUP: 2351
      8				     ;**************************************************************************
      9
     10				     ; DATA SEGMENT DEFINITION
     11	0000			     DATOS SEGMENT
     12
     13
     14	0000  1B 5B 32 4A 24		     CLEAR_SCREEN    DB	     1BH,"[2","J$"
     15	0005  50 6C 65 61 73 65	2C+	 STATEMENT DB "Please, write the message you want to encode: ",	13, 10,	"$"
     16	      20 77 72 69 74 65	20+
     17	      74 68 65 20 6D 65	73+
     18	      73 61 67 65 20 79	6F+
     19	      75 20 77 61 6E 74	20+
     20	      74 6F 20 65 6E 63	6F+
     21	      64 65 3A 20 0D 0A	24
     22
     23	0036  4F 75 72 20 64 72	69+	 ERRORCODE DB "Our driver is not correctly installed", 13, 10 ,	'$'
     24	      76 65 72 20 69 73	20+
     25	      6E 6F 74 20 63 6F	72+
     26	      72 65 63 74 6C 79	20+
     27	      69 6E 73 74 61 6C	6C+
     28	      65 64 0D 0A 24
     29	005E  54 68 65 20 6D 65	73+	 PRINT1	DB "The	message	you are	encoding is: ",	'$'
     30	      73 61 67 65 20 79	6F+
     31	      75 20 61 72 65 20	65+
     32	      6E 63 6F 64 69 6E	67+
     33	      20 69 73 3A 20 24
     34	0080  54 68 65 20 65 6E	63+	 PRINT2	DB "The	encoded	message	is: ", '$'
     35	      6F 64 65 64 20 6D	65+
     36	      73 73 61 67 65 20	69+
     37	      73 3A 20 24
     38	0099  54 68 65 20 64 65	63+	 PRINT3	DB "The	decoded	message	is: ", '$'
     39	      6F 64 65 64 20 6D	65+
     40	      73 73 61 67 65 20	69+
     41	      73 3A 20 24
     42	00B2  64*(??)			 MESSAGE DB 100	dup (?)
     43	0116  0D 0A 24			 LINEJUMP DB 13,10, '$'
     44
     45	0119			     DATOS ENDS
     46				     ;**************************************************************************
     47				     ; STACK SEGMENT DEFINITION
     48	0000			     PILA SEGMENT STACK	"STACK"
     49	0000  40*(00)			     DB	40h DUP	(0) ; initialization example, 64 bytes set to 0
     50	0040			     PILA ENDS
     51
     52
     53				     ;**************************************************************************
     54				     ; CODE SEGMENT DEFINITION
     55	0000			     CODE SEGMENT
     56				     ASSUME CS:	CODE, DS: DATOS, SS: PILA
     57				     ; BEGINNING OF THE	MAIN PROCEDURE
Turbo Assembler	 Version 2.0	    05/03/18 02:29:32	    Page 2
p4b.asm



     58	0000			     INICIO PROC
     59					     ; INITIALIZE THE SEGMENT REGISTERS
     60	0000  B8 0000s			     MOV AX, DATOS
     61	0003  8E D8			     MOV DS, AX
     62	0005  B8 0000			     MOV AX, 0
     63	0008  8E C0			     MOV ES, AX
     64
     65
     66					     ; We have to check	if our driver is correcly installed
     67	000A  B1 00			     MOV CL, 0
     68	000C  E8 0075			     CALL CHECK_DRIVER
     69	000F  80 F9 01			     CMP CL, 1
     70	0012  74 0A			     JE	DRIVER_OK
     71
     72
     73
     74	0014			     ERROR:
     75
     76					     ; Printing	an ERRORCODE
     77	0014  BA 0036r			     MOV DX, OFFSET ERRORCODE
     78	0017  B4 09			     MOV AH, 9
     79	0019  CD 21			     INT 21H
     80
     81	001B  EB 62 90			     JMP JEND
     82
     83	001E			     DRIVER_OK:
     84
     85					     ; CLEARS THE SCREEN
     86	001E  B4 09			     MOV AH,9
     87	0020  BA 0000r			     MOV DX, OFFSET CLEAR_SCREEN
     88	0023  CD 21			     INT 21H
     89
     90					     ; PRINTS THE MESSAGE REQUEST
     91	0025  BA 0005r			     MOV DX, OFFSET STATEMENT
     92	0028  CD 21			     INT 21H
     93
     94					     ; STORES THE MESSAGE IN MEMORY
     95	002A  B4 0A			     MOV AH,0AH
     96	002C  BA 00B2r			     MOV DX, OFFSET MESSAGE
     97	002F  C6 06 00B2r 5A		     MOV MESSAGE[0], 90
     98	0034  CD 21			     INT 21H
     99
    100					     ; Check out if the	MESSAGE'S lenght is not	null
    101	0036  B7 00			     MOV BH, 0
    102	0038  8A 1E 00B3r		     MOV BL, MESSAGE[1]
    103	003C  80 FB 00			     CMP BL, 0
    104	003F  74 3E			     JE	JEND
    105
    106					     ; In order	to print the message correctly,	we have	to write the $ right after the last +
    107				     character
    108	0041  C6 87 00B4r 24		     MOV MESSAGE[BX+2],	'$'
    109
    110
    111					     ; PRINTS THE MESSAGE WRITTEN BY THE USER
    112	0046  B4 09			     MOV AH,9
    113	0048  BA 005Er			     MOV DX, OFFSET PRINT1
    114	004B  CD 21			     INT 21H
Turbo Assembler	 Version 2.0	    05/03/18 02:29:32	    Page 3
p4b.asm



    115
    116	004D  BA 00B4r			     MOV DX, OFFSET MESSAGE[2]
    117	0050  CD 21			     INT 21H
    118
    119					     ; Printing	a line jump
    120	0052  BA 0116r			     MOV DX, OFFSET LINEJUMP
    121	0055  CD 21			     INT 21H
    122
    123
    124					     ; CASE 1: ENCRYPTION
    125	0057  BA 0080r			     MOV DX, OFFSET PRINT2
    126	005A  CD 21			     INT 21H
    127
    128					     ; We push DS in order to keep it: We might	need it	later
    129	005C  1E			     push DS
    130
    131					     ; We use message[2] because the first two bytes of	the read message are the maximum    +
    132				     size and the real size.
    133					     ; We dont want to codify them
    134	005D  BA 00B4r			     MOV DX, OFFSET MESSAGE[2]
    135	0060  BB 0000s			     MOV BX, SEG MESSAGE
    136	0063  8E DB			     MOV DS, BX
    137
    138					     ; Calling of the interruption
    139					     ; 12h => ENCRYPTION
    140	0065  B4 12			     MOV AH, 12h
    141	0067  CD 55			     INT 55h
    142
    143					     ; Restoring DS
    144	0069  1F			     pop DS
    145
    146					     ; Printing	a line jump
    147	006A  B4 09			     MOV AH, 9h
    148	006C  BA 0116r			     MOV DX, OFFSET LINEJUMP
    149	006F  CD 21			     INT 21H
    150
    151
    152					     ; CASE 2: DECRYPTION
    153	0071  BA 0099r			     MOV DX, OFFSET PRINT3
    154	0074  CD 21			     INT 21H
    155
    156					     ; We push DS in order to keep it: We might	need it	later
    157	0076  1E			     push DS
    158
    159	0077  BA 00B4r			     MOV DX, OFFSET MESSAGE[2]
    160	007A  B4 13			     MOV AH, 13h
    161
    162					     ; Calling of the interruption
    163					     ; 13h => DECRYPTION
    164	007C  CD 55			     INT 55h
    165
    166	007E  1F			     POP DS
    167
    168
    169					     ; PROGRAM END
    170	007F			     JEND:
    171	007F  B8 4C00			 MOV AX, 4C00h
Turbo Assembler	 Version 2.0	    05/03/18 02:29:32	    Page 4
p4b.asm



    172	0082  CD 21			     INT 21h
    173	0084			     INICIO ENDP
    174
    175
    176				     ; This function writes on CL
    177				     ; After the execution:
    178				     ; CL = 0 if there isnt any	driver at 55h
    179				     ; CL = 1 if the installed driver is ours.
    180				     ; CL = 2 if there is a driver, but	it is not ours.
    181	0084			     CHECK_DRIVER PROC NEAR
    182
    183	0084  57 56 50			     PUSH DI SI	AX
    184
    185					     ; We have to check	if there is a driver in	55h
    186					     ; If so, we would like to know if it is our driver
    187	0087  26: 8B 3E	0154		     MOV DI, ES:[ 55h*4	]
    188	008C  26: 8B 36	0156		     MOV SI, ES:[ 55h*4	+2 ]
    189					     ; We check	if there are 0s	in the interruption vector
    190	0091  83 FF 00			     CMP DI, 0
    191	0094  75 0A			     JNE DRIVER_EXISTS
    192	0096  83 FE 00			     CMP SI, 0
    193	0099  75 05			     JNE DRIVER_EXISTS
    194
    195					     ; If we have reached this point it	means there is no driver installed at all.
    196	009B  B1 00			     MOV CL, 0
    197	009D  EB 0E 90			     JMP END_CHECK
    198
    199	00A0			     DRIVER_EXISTS:
    200
    201	00A0  B1 00			     MOV CL, 0
    202	00A2  B4 08			     MOV AH, 08h
    203	00A4  CD 55			     INT 55h
    204					     ; If the interruption with	AH = 08h changes CL from 0 to 1, then it should	be our	    +
    205				     interruption.
    206	00A6  80 F9 01			     CMP CL, 1
    207	00A9  74 02			     JE	END_CHECK
    208
    209					     ; The other possible case is: there is a driver, but it isnt the one we want.
    210	00AB  B1 02			     MOV CL, 2
    211
    212	00AD			     END_CHECK:
    213	00AD  58 5E 5F			     POP AX SI DI
    214	00B0  C3			     RET
    215
    216	00B1			     CHECK_DRIVER ENDP
    217
    218
    219				     ; END OF CODE SEGMENT
    220	00B1			     CODE ENDS
    221				     ; END OF PROGRAM. OBS: INCLUDES THE ENTRY FOR THE FIRST PROCEDURE (i.e. “INICIO”)
    222				     END INICIO
Turbo Assembler	 Version 2.0	    05/03/18 02:29:32	    Page 5
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "05/03/18"
??FILENAME			  Text	 "p4b	  "
??TIME				  Text	 "02:29:32"
??VERSION			  Number 0200
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 P4B
@WORDSIZE			  Text	 2
CHECK_DRIVER			  Near	 CODE:0084
CLEAR_SCREEN			  Byte	 DATOS:0000
DRIVER_EXISTS			  Near	 CODE:00A0
DRIVER_OK			  Near	 CODE:001E
END_CHECK			  Near	 CODE:00AD
ERROR				  Near	 CODE:0014
ERRORCODE			  Byte	 DATOS:0036
INICIO				  Near	 CODE:0000
JEND				  Near	 CODE:007F
LINEJUMP			  Byte	 DATOS:0116
MESSAGE				  Byte	 DATOS:00B2
PRINT1				  Byte	 DATOS:005E
PRINT2				  Byte	 DATOS:0080
PRINT3				  Byte	 DATOS:0099
STATEMENT			  Byte	 DATOS:0005

Groups & Segments		  Bit Size Align  Combine Class

CODE				  16  00B1 Para	  none
DATOS				  16  0119 Para	  none
PILA				  16  0040 Para	  Stack	  STACK
