Turbo Assembler	 Version 2.0	    04/30/18 03:16:13	    Page 1
p4b.asm



      1				     ;**************************************************************************
      2				     ; MICROPROCESSOR-BASED SYSTEMS
      3				     ; LAB SESSION 2
      4				     ; FILE: labs2b.asm
      5				     ; AUTHORS:	Emilio Cuesta Fernandez	- Alejandro Sanchez Sanz
      6				     ; COUPLE NUMBER: 8
      7				     ; GROUP: 2351
      8				     ;**************************************************************************
      9
     10				     ; DATA SEGMENT DEFINITION
     11	0000			     DATOS SEGMENT
     12
     13
     14	0000  1B 5B 32 4A 24		     CLEAR_SCREEN    DB	     1BH,"[2","J$"
     15	0005  50 6C 65 61 73 65	2C+	 STATEMENT DB "Please, write the message you want to encode: ",	13, 10,	"$"
     16	      20 77 72 69 74 65	20+
     17	      74 68 65 20 6D 65	73+
     18	      73 61 67 65 20 79	6F+
     19	      75 20 77 61 6E 74	20+
     20	      74 6F 20 65 6E 63	6F+
     21	      64 65 3A 20 0D 0A	24
     22
     23	0036  54 68 65 20 64 72	69+	 ERRORCODE DB "The driver was not installed correctly"
     24	      76 65 72 20 77 61	73+
     25	      20 6E 6F 74 20 69	6E+
     26	      73 74 61 6C 6C 65	64+
     27	      20 63 6F 72 72 65	63+
     28	      74 6C 79
     29	005C  54 68 65 20 6D 65	73+	 PRINT1	DB "The	message	you are	encoding is: ",	'$'
     30	      73 61 67 65 20 79	6F+
     31	      75 20 61 72 65 20	65+
     32	      6E 63 6F 64 69 6E	67+
     33	      20 69 73 3A 20 24
     34	007E  54 68 65 20 65 6E	63+	 PRINT2	DB "The	encoded	message	is: ", '$'
     35	      6F 64 65 64 20 6D	65+
     36	      73 73 61 67 65 20	69+
     37	      73 3A 20 24
     38	0097  54 68 65 20 64 65	63+	 PRINT3	DB "The	decoded	message	is: ", '$'
     39	      6F 64 65 64 20 6D	65+
     40	      73 73 61 67 65 20	69+
     41	      73 3A 20 24
     42	00B0  64*(??)			 MESSAGE DB 100	dup (?)
     43	0114  0D 0A 24			 LINEJUMP DB 13,10, '$'
     44
     45	0117			     DATOS ENDS
     46				     ;**************************************************************************
     47				     ; STACK SEGMENT DEFINITION
     48	0000			     PILA SEGMENT STACK	"STACK"
     49	0000  40*(00)			     DB	40h DUP	(0) ; initialization example, 64 bytes set to 0
     50	0040			     PILA ENDS
     51
     52
     53				     ;**************************************************************************
     54				     ; CODE SEGMENT DEFINITION
     55	0000			     CODE SEGMENT
     56				     ASSUME CS:	CODE, DS: DATOS, SS: PILA
     57				     ; BEGINNING OF THE	MAIN PROCEDURE
Turbo Assembler	 Version 2.0	    04/30/18 03:16:13	    Page 2
p4b.asm



     58	0000			     INICIO PROC
     59					     ; INITIALIZE THE SEGMENT REGISTERS
     60	0000  B8 0000s			     MOV AX, DATOS
     61	0003  8E D8			     MOV DS, AX
     62	0005  B8 0000			     MOV AX, 0
     63	0008  8E C0			     MOV ES, AX
     64
     65					     ; We have to check	if there is a driver already installed in 55h
     66	000A  26: 8B 3E	0154		     MOV DI, ES:[ 55h*4	]
     67	000F  26: 8B 36	0156		     MOV SI, ES:[ 55h*4	+2 ]
     68					     ; We check	if there are 0s	in the interruption vector
     69					     ; This fails in the first attempt
     70	0014  83 FF 00			     CMP DI, 0
     71	0017  75 0F			     JNE DRIVER_OK
     72	0019  83 FE 00			     CMP SI, 0
     73	001C  75 0A			     JNE DRIVER_OK
     74
     75
     76					     ; Printing	an ERRORCODE
     77	001E  BA 0036r			     MOV DX, OFFSET ERRORCODE
     78	0021  B4 09			     MOV AH, 9
     79	0023  CD 21			     INT 21H
     80
     81
     82	0025  EB 62 90			     JMP JEND
     83
     84	0028			     DRIVER_OK:
     85
     86					     ; CLEARS THE SCREEN
     87	0028  B4 09			     MOV AH,9
     88	002A  BA 0000r			     MOV DX, OFFSET CLEAR_SCREEN
     89	002D  CD 21			     INT 21H
     90
     91					     ; PRINTS THE MESSAGE REQUEST
     92	002F  BA 0005r			     MOV DX, OFFSET STATEMENT
     93	0032  CD 21			     INT 21H
     94
     95					     ; STORES THE MESSAGE IN MEMORY
     96	0034  B4 0A			     MOV AH,0AH
     97	0036  BA 00B0r			     MOV DX, OFFSET MESSAGE
     98	0039  C6 06 00B0r 5A		     MOV MESSAGE[0], 90
     99	003E  CD 21			     INT 21H
    100
    101					     ; Check out if the	MESSAGE'S lenght is not	null
    102	0040  B7 00			     MOV BH, 0
    103	0042  8A 1E 00B1r		     MOV BL, MESSAGE[1]
    104	0046  80 FB 00			     CMP BL, 0
    105	0049  74 3E			     JE	JEND
    106
    107					     ; In order	to print the message correctly,	we have	to write the $ right after the last +
    108				     character
    109	004B  C6 87 00B2r 24		     MOV MESSAGE[BX+2],	'$'
    110
    111
    112					     ; PRINTS THE MESSAGE WRITTEN BY THE USER
    113	0050  B4 09			     MOV AH,9
    114	0052  BA 005Cr			     MOV DX, OFFSET PRINT1
Turbo Assembler	 Version 2.0	    04/30/18 03:16:13	    Page 3
p4b.asm



    115	0055  CD 21			     INT 21H
    116
    117	0057  BA 00B2r			     MOV DX, OFFSET MESSAGE[2]
    118	005A  CD 21			     INT 21H
    119
    120					     ; Printing	a line jump
    121	005C  BA 0114r			     MOV DX, OFFSET LINEJUMP
    122	005F  CD 21			     INT 21H
    123
    124
    125					     ; CASE 1: ENCRYPTION
    126	0061  BA 007Er			     MOV DX, OFFSET PRINT2
    127	0064  CD 21			     INT 21H
    128
    129					     ; We push DS in order to keep it: We might	need it	later
    130	0066  1E			     push DS
    131
    132					     ; We use message[2] because the first two bytes of	the read message are the maximum    +
    133				     size and the real size.
    134					     ; We dont want to codify them
    135	0067  BA 00B2r			     MOV DX, OFFSET MESSAGE[2]
    136	006A  BB 0000s			     MOV BX, SEG MESSAGE
    137	006D  8E DB			     MOV DS, BX
    138
    139					     ; Calling of the interruption
    140					     ; 12h => ENCRYPTION
    141	006F  B4 12			     MOV AH, 12h
    142	0071  CD 55			     INT 55h
    143
    144					     ; Restoring DS
    145	0073  1F			     pop DS
    146
    147					     ; Printing	a line jump
    148	0074  B4 09			     MOV AH, 9h
    149	0076  BA 0114r			     MOV DX, OFFSET LINEJUMP
    150	0079  CD 21			     INT 21H
    151
    152
    153					     ; CASE 2: DECRYPTION
    154	007B  BA 0097r			     MOV DX, OFFSET PRINT3
    155	007E  CD 21			     INT 21H
    156
    157					     ; We push DS in order to keep it: We might	need it	later
    158	0080  1E			     push DS
    159
    160	0081  BA 00B2r			     MOV DX, OFFSET MESSAGE[2]
    161	0084  B4 13			     MOV AH, 13h
    162
    163					     ; Calling of the interruption
    164					     ; 13h => DECRYPTION
    165	0086  CD 55			     INT 55h
    166
    167	0088  1F			     POP DS
    168
    169
    170					     ; PROGRAM END
    171	0089			     JEND:
Turbo Assembler	 Version 2.0	    04/30/18 03:16:13	    Page 4
p4b.asm



    172	0089  B8 4C00			 MOV AX, 4C00h
    173	008C  CD 21			     INT 21h
    174	008E			     INICIO ENDP
    175
    176				     ; We implement the	function to compute the	parity bits in an automatic way
    177
    178
    179				     ; END OF CODE SEGMENT
    180	008E			     CODE ENDS
    181				     ; END OF PROGRAM. OBS: INCLUDES THE ENTRY FOR THE FIRST PROCEDURE (i.e. “INICIO”)
    182				     END INICIO
Turbo Assembler	 Version 2.0	    04/30/18 03:16:13	    Page 5
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "04/30/18"
??FILENAME			  Text	 "p4b	  "
??TIME				  Text	 "03:16:13"
??VERSION			  Number 0200
@CPU				  Text	 0101H
@CURSEG				  Text	 CODE
@FILENAME			  Text	 P4B
@WORDSIZE			  Text	 2
CLEAR_SCREEN			  Byte	 DATOS:0000
DRIVER_OK			  Near	 CODE:0028
ERRORCODE			  Byte	 DATOS:0036
INICIO				  Near	 CODE:0000
JEND				  Near	 CODE:0089
LINEJUMP			  Byte	 DATOS:0114
MESSAGE				  Byte	 DATOS:00B0
PRINT1				  Byte	 DATOS:005C
PRINT2				  Byte	 DATOS:007E
PRINT3				  Byte	 DATOS:0097
STATEMENT			  Byte	 DATOS:0005

Groups & Segments		  Bit Size Align  Combine Class

CODE				  16  008E Para	  none
DATOS				  16  0117 Para	  none
PILA				  16  0040 Para	  Stack	  STACK
